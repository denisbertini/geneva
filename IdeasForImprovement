- Add cross-over function to GStdVector interfaces
- Shifting in multi-populations
- Prevent GBrokerPopulation from being used inside itself (doesn't make sense, will likely not work)
- Use one of the Boost logging library candidates. Requires that at least one 
  of them heads for a review (we do not want to include further candidate libraries. Geneva should work with a 
  vanilla Boost installation (>= 1.36)
- data_time usage in GBasePopulation::optimize() might lead to problems in multi-populations (-> thread-safety)
- Add a CMake macro "FindGeneva.cmake"
- Allow clients in network mode to pull over a series of individuals
- Transfer parents rather than children
- Allow clients to create a series of copies from the master individual by themself and return the best one
- Additional network implementations (MPI, PVM, ...)
- Implement *1.5 vs. /0.5 rule for sigma adaption. Can be based on the parentCounter_ variable
  of individuals.
- GSelectedChar should allow a selection of the characters to be mutated. Very similar:
  An integer class that allows mutation between several selected integers only.
- Clean up comments and run doxygen
- Implement a "trap" in GRandom and provide specializations for "allowed" types rather than 
  specializations for "forbidden" types
- Check how often the GRandomFactory queue is empty or full. Automatic adaption of number of threads ?
- Implement a chi-square test for the randomness of our generator, as a basic means of ensuring that 
  our random number generator does the right thing.
- When boundaries are at the maximum in GBoundedNumT<>, simply return the "in" value after the transformation
- Make the external evaluation program read a configuration file rather than the command line
- Network transfer of the parent rather than the child to avoid transfer of multiple, identical child items
  Local duplication AND mutation
- Clients may ask to be sent m>n items, sending back only the n best items. Needs new command duplicate.
  Order DUPLICATE(M) -> MUTATE -> EVALUATE. Earlier orders imply the latter
- Network transfers initiated by clients in separate thread, in parallel to the calculation, thereby eliminating 
  part of the network overhead
- It should be possible to ask individuals to take charge of the external evaluation of other individuals as well, avoiding generation of local, random copies
- RNR in float faster ?
- Rename GBasePopulation and/or GBrokerPopulation, e.g. to GenevaPopulation ?
- Add GSwarm, GSteepestDescent ?
- Catch signals in the network clients, so that we are sure that we complete network transfers before stopping
- Use the Boost.Filesystem library to access data on the disk - makes Geneva portable to Windows.
- GThreadGroup could be given a vector interface
- gLite submission script
- Observe, which parameters change a lot in successful mutations. Try to predominantly modify these parameters and keep the other parameters const. Could be done with a kind of line search ?
- Create a script or small program that emits the inidividual's .hpp and .cpp stubs, ready to be be completed by the user. Something along the lines of 
  "createStubs.sh myIndividualClassName
- Do checks for equality and similarity of base types through GObject::notEqual() and GObject::notSimilar(), that can 
  additionally emit information on the location of the deviation, if requested. Performance is not an issue for these functions
- The GNeuralNetworkIndividual needs to be renovated (e.g. the isEqualTo function needs to be added).
- Same for GNoisyParabolaIndividual and GProjectionIndividual
- Separate useful individuals (neural network, external evaluation, ...) from pure examples
- Create boost::shared_ptr<GObject> versions of load() and clone(), adapt in all places (e.g. GStdPtrVectorInterface.hpp)
- Test that seeding works with local random number creation
- Track down all uses of setSigmaRange and associates and check for consistency
- Need an infrastructure to give a single adaptor to an object collection !!
- Make most GRandom functions const, then hand down a constant reference to the parameter sets
- Check whether we need to declare anything as volatile, particularly in connection with random number generation
- Remove the eval_ function from GParameterSet ... . Useless in parallel environments (?)
- Is GIndividualSet really needed ? Could all be handled from GBasePopulation ? But no: can serve as the base class for a GSwarm 
  or a GGradientDescent
- Check in GStdPtrVectorInterface whether smart pointers actually point somewhere. Otherwise
  just copy an empty pointer (or throw ?? Different behavior in DEBUG mode ?)
- Check all load code whether it checks for empty smart pointers. Always check in DEBUG mode.
- Use CPack to create DEB packages (RPM already implemented)
- Switch examples to the noisy parabola, due to its higher learning potential
- Only compile tests if test_exec_monitor library could be found (not always in default installations)
- Renovation of client / consumer infrastructure (clean base classes, separation of protocol from network implementation)
- Test checkpointing of Geneva objects
- Make clients run in multi-threaded mode so they can pull a user-defined number of items over

Nice to have:
- Coding central routines (particularly even RNR generation and transformation to gaussian RNR) in assembler ? (Would be fun ...)
- De-central sorting (by letting clients communicate)
- Script that scans which files contain which license types and creates a report
- Make individuals optionally output their information in ROOT-tree format (see http://root.cern.ch). Can
  be done with the info function framework ??
- Recycling of partially used random number blocks. Can be done by also storing the current01-pointer in the array and 
  re-injecting the array in the random-factory's queue. Also reduces the size of the GRandom objects. Recycling should be
  triggered upon destruction of the GRandom object, or when another production mode is chosen.
  
- Add cross-over function to GParameterCollectionT
- Shifting in multi-populations
- Prevent GBrokerPopulation from being used inside itself (doesn't make sense, will likely not work)
- Make individuals output their information in ROOT-tree format (see http://root.cern.ch). Can
  be done with the info function framework ??
- Move from GLogger to one of the two Boost logging library candidates. Requires that at least one 
  of them heads for a review (we do not want to include further candidate libraries. Geneva should work with a 
  vanilla Boost installation (>= 1.36)
- Ship the threadpool library with Geneva or move to standard Boost threadpool (once it has been reviewed)
- Add many more tests using the Boost.Test library
- data_time usage in GBasePopulation::optimize() might lead to problems in multi-populations (-> thread-safety)
- Add a CMake macro "FindGeneva.cmake"
- An operator=(const std::vector<num_type> for GNumCollectionT and similar std::vector look-alikes
- Complete GMutatableT std::vector wrapper (see GParameterTCollectionT class)
- Stop criterium "quality is below or above a given threshold"
- Allow clients in network mode to pull over a series of individuals
- Allow clients to create a series of copies from the master individual by themself and return the best one
- De-central sorting (by letting clients communicate)
- Additional network implementations (MPI, PVM, ...)
- Further optimization algorithms: gradient descents, swarm, ...
- Split tests into "failures expected" and "no failures expected"
- Test for self-assignment can be eliminated in all classes derived from GObject, as GObject will
  be first to check. One check is sufficient.
- Implement *1.5 vs. /0.5 rule for sigma adaption. Can be based on the parentCounter_ variable
  of individuals.
- Add a GBiDoubleGaussAdaptor
- GSelectedChar should allow a selection of the characters to be mutated. Very similar:
  An integer class that allows mutation between several selected integers only.
- Clean up comments and run doxygen
- Implement a "trap" in GRandom and provide specializations for "allowed" types rather than 
  specializations for "forbidden" types
- Check GRandom in unit tests (e.g.: discreteRandom never returns the upper boundary. Also needed
  for GBoundedInt32 aka GBoundedNumT<boost::int32_t> .
- Check how often the GRandomFactory queue is empty or full. Automatic adaption of number of threads ?
- Implement a chi-square test for the randomness of our generator, as a basic means of ensuring that 
  our random number generator does the right thing.
- Create plots for Gauss mutation (the result of the adaptor) for unbounded and bounded doubles and ints.
  Need to check possible distortions of the gaussian at the "edges" of a variable's allowed data range.
- When boundaries are at the maximum in GBoundedNumT<>, simply return the "in" value after the transformation
- Allow to supply template items to the GExternalEvaluator in an easy way (particularly the adaptors are important!)
- Make the external evaluation program read a configuration file rather than the command line
- Network transfer of the parent rather than the child to avoid transfer of multiple, identical child items
  Local duplication AND mutation
- Clients may ask to be sent m>n items, sending back only the n best items. Needs new command duplicate.
  Order DUPLICATE(M) -> MUTATE -> EVALUATE. Earlier orders imply the latter
- Network transfers initiated by clients in separate thread, in parallel to the calculation, thereby eliminating 
  part of the network overhead
- Coding central routines (particularly even RNR generation and transformation to gaussian RNR in assembler ? (Would be fun ...)

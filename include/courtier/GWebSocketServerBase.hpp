/**
 * @file GWebSocketServerBase.hpp
 */

/*
 * The code in this file is derived from code created by Vinnie Falco as
 * part of the Websocket implenentation "Beast" (cmp. https://github.com/vinniefalco/Beast),
 * and is covered by the Boost software license like the original code.
 * The following copyright header was contained in the original file (websocket_async_echo_server.hpp).
 * It is repeated here as per the requirements of the Boost Software License:
 *
 * --------------------------------------------------------------------------
 * Copyright (c) 2013-2016 Vinnie Falco (vinnie dot falco at gmail dot com)
 *
 * Distributed under the Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 * --------------------------------------------------------------------------
 *
 * The following license applies to the code in this file:
 *
 * ***************************************************************************
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * ***************************************************************************
 *
 * All changes to the original code, as contained in this file, are
 * Copyright (c) Gemfony scientific UG (haftungsbeschraenkt).
 *
 * Contact: contact [at] gemfony (dot) eu
 *
 * This file is part of the Geneva library collection. NOTE that other
 * licenses may apply to other parts of Geneva. See the license notes in
 * each file for further information.
 *
 * For further information on Gemfony scientific and Geneva, visit
 * http://www.gemfony.eu .
 */

// Global checks, defines and includes needed for all of Geneva
#include "common/GGlobalDefines.hpp"

// Standard headers go here
#include <functional>
#include <iostream>
#include <memory>
#include <thread>

// Boost headers go here
#include "boost/lexical_cast.hpp"
#include "boost/optional.hpp"

#ifndef GENEVA_LIBRARY_COLLECTION_GWEBSOCKETSERVERBASE_HPP
#define GENEVA_LIBRARY_COLLECTION_GWEBSOCKETSERVERBASE_HPP

// Geneva or thirdparty headers go here
#include "thirdparty/beast/core/placeholders.hpp"
#include "thirdparty/beast/core/streambuf.hpp"
#include "thirdparty/beast/websocket.hpp"

// Alias for ease of use
namespace bw = beast::websocket;

namespace Gem {
namespace Courtier {

using endpoint_type = boost::asio::ip::tcp::endpoint;
using address_type = boost::asio::ip::address;
using socket_type = boost::asio::ip::tcp::socket;

/******************************************************************************/
////////////////////////////////////////////////////////////////////////////////
/******************************************************************************/
/**
 * This struct encodes data associated with a GWebsocketServerSessionBase
 */
struct ws_data {
	 ws_data(bool log, socket_type&& socket)
		 : m_log(log)
		 , m_ws(std::move(socket))
		 , m_strand(m_ws.get_io_service())
		 , m_id([] { static int n = 0; return ++n; }())
	 { /* nothing */ }

	 ws_data(bool log, socket_type&& socket, endpoint_type const& ep)
		 : m_log(log)
		 , m_ep(ep)
		 , m_ws(std::move(socket))
		 , m_strand(m_ws.get_io_service())
		 , m_id([] { static int n = 0; return ++n; }())
	 { /* nothing */ }

	 /**************************************************************************/
	 // Data

	 bool m_log;
	 int m_state = 0;
	 boost::optional<endpoint_type> m_ep;
	 bw::stream<socket_type> m_ws;
	 boost::asio::io_service::strand m_strand;
	 opcode m_op;
	 beast::streambuf m_db;
	 int m_id;
};

/******************************************************************************/
////////////////////////////////////////////////////////////////////////////////
/******************************************************************************/
/**
 * Emits information about the caller
 */
struct identity {
	 template<class Body, class Headers>
	 void operator()(bw::http::message<true, Body, Headers>& req) {
		 req.headers.replace("User-Agent", "GWebsocketServerSessionBase");
	 }

	 template<class Body, class Headers>
	 void operator()(bw::http::message<false, Body, Headers>& resp) {
		 resp.headers.replace("Server", "GWebsocketServerSessionBase");
	 }
};

/******************************************************************************/
////////////////////////////////////////////////////////////////////////////////
/******************************************************************************/
/**
 * An instance of this class is created for each new connection initiated
 * by the client. All the details of the data exchange between server
 * and client are implemented here or in derived classes
 */
class GWebsocketServerSessionBase {
public:
	 GWebsocketServerSessionBase(GWebsocketServerSessionBase&&) = default;
	 GWebsocketServerSessionBase(GWebsocketServerSessionBase const&) = default;
	 GWebsocketServerSessionBase& operator=(GWebsocketServerSessionBase&&) = delete;
	 GWebsocketServerSessionBase& operator=(GWebsocketServerSessionBase const&) = delete;

	 template<class... Args>
	 explicit GWebsocketServerSessionBase(
		 bool log
		 , socket_type&& sock
		 , Args&&... args
	 )
		 : m_d(std::make_shared<ws_data>(log, std::forward<socket_type>(sock), std::forward<Args>(args)...))
	 {
		 m_d->m_ws.set_option(bw::decorate(identity{}));
		 m_d->m_ws.set_option(bw::read_message_max(64 * 1024 * 1024));
		 run();
	 }

	 void run() {
		 if(! m_d->m_ep) {
			 m_d->m_ws.async_accept(std::move(*this));
		 } else {
			 m_d->m_state = 4;
			 m_d->m_ws.next_layer().async_connect(
				 *(m_d->m_ep)
				 , std::move(*this)
			 );
		 }
	 }

	 template<class DynamicBuffer, std::size_t N>
	 static bool match(
		 DynamicBuffer& db
		 , char const(&s)[N]
	 ) {
		 using boost::asio::buffer;
		 using boost::asio::buffer_copy;

		 if(db.size() < N-1) {
			 return false;
		 }
		 bw::static_string<N-1> t;
		 t.resize(N-1);
		 buffer_copy(
			 buffer(
				 t.data()
				 , t.size()
			 )
			 , db.data()
		 );
		 if(t != s) {
			 return false;
		 }
		 db.consume(N-1);
		 return true;
	 }

	 void operator()(
		 bw::error_code ec
		 , std::size_t
	 ) {
		 (*this)(ec);
	 }

	 void operator()(bw::error_code ec) {
		 using boost::asio::buffer;
		 using boost::asio::buffer_copy;

		 switch(m_d->m_state) {
			 // did accept
			 case 0:
				 if(ec) return fail(ec, "async_accept");

				 // start
			 case 1:
				 if(ec) return fail(ec, "async_handshake");
				 m_d->m_db.consume(m_d->m_db.size());
				 // read message
				 m_d->m_state = 2;
				 m_d->m_ws.async_read(m_d->m_op, m_d->m_db,
					 m_d->m_strand.wrap(std::move(*this)));
				 return;

				 // got message
			 case 2:
				 if(ec == error::closed) return;
				 if(ec) return fail(ec, "async_read");
				 if(match(m_d->m_db, "RAW")) {
					 m_d->m_state = 1;
					 boost::asio::async_write(m_d->m_ws.next_layer(),
						 m_d->m_db.data(), m_d->m_strand.wrap(std::move(*this)));
					 return;
				 }  else if(match(m_d->m_db, "TEXT")) {
					 m_d->m_state = 1;
					 m_d->m_ws.set_option(message_type{opcode::text});
					 m_d->m_ws.async_write(
						 m_d->m_db.data(), m_d->m_strand.wrap(std::move(*this)));
					 return;
				 } else if(match(m_d->m_db, "PING")) {
					 ping_data payload;
					 m_d->m_db.consume(
						 buffer_copy(
							 buffer(
								 payload.data()
								 , payload.size()
							 )
							 , m_d->m_db.data()
						 )
					 );
					 m_d->m_state = 1;
					 m_d->m_ws.async_ping(payload,
						 m_d->m_strand.wrap(std::move(*this)));
					 return;
				 } else if(match(m_d->m_db, "CLOSE")) {
					 m_d->m_state = 1;
					 m_d->m_ws.async_close(
						 {}
						 , m_d->m_strand.wrap(std::move(*this))
					 );
					 return;
				 }

				 // write message
				 m_d->m_state = 1;
				 m_d->m_ws.set_option(message_type(m_d->m_op));
				 m_d->m_ws.async_write(
					 m_d->m_db.data()
					 , m_d->m_strand.wrap(std::move(*this))
				 );
				 return;

				 // connected
			 case 4:
				 if(ec)
					 return fail(ec, "async_connect");
				 m_d->m_state = 1;
				 m_d->m_ws.async_handshake(
					 m_d->m_ep->address().to_string() + ":" + boost::lexical_cast<std::string>(m_d->m_ep->port())
					 , "/"
					 , m_d->m_strand.wrap(std::move(*this))
				 );
				 return;
		 }
	 }

private:
	 void fail(bw::error_code ec, std::string what) {
		 if(m_d->m_log) {
			 if(ec != bw::error::closed) {
				 std::cerr
					 << "#" << m_d->m_id << " " << what << ": " << ec.message() << std::endl;
			 }
		 }
	 }

	 /**************************************************************************/
	 // Data

	 std::shared_ptr<ws_data> m_d;
};

/******************************************************************************/
////////////////////////////////////////////////////////////////////////////////
/******************************************************************************/

class GWebSocketServerBase {
public:
	 GWebSocketServerBase(
		 bool server
		 , endpoint_type const& ep
		 , std::size_t threads
	 )
		 : m_socket(m_ios)
	 	 , m_acceptor(m_ios)
	 {
		 if(server) {
			 bw::error_code ec;
			 m_acceptor.open(ep.protocol(), ec);
			 maybe_throw(ec, "open");
			 m_acceptor.set_option(
				 boost::asio::socket_base::reuse_address{true}
			 );
			 m_acceptor.bind(ep, ec);
			 maybe_throw(ec, "bind");
			 m_acceptor.listen(
				 boost::asio::socket_base::max_connections
				 , ec
			 );
			 maybe_throw(ec, "listen");
			 m_acceptor.async_accept(
				 m_socket
				 , std::bind(
					 &GWebSocketServerBase::on_accept
					 , this
					 , beast::asio::placeholders::error
				 )
			 );
		 } else {
			 GWebsocketServerSessionBase{m_log, std::move(m_socket), ep};
		 }
		 m_thread_vec.reserve(threads);
		 for(std::size_t i = 0; i < threads; ++i) {
			 m_thread_vec.emplace_back(
				 [&] { m_ios.run(); }
			 );
		 }
	 }

	 ~GWebSocketServerBase() {
		 bw::error_code ec;
		 m_ios.dispatch(
			 [&]{ m_acceptor.close(ec); }
		 );
		 for(auto& t : m_thread_vec) {
			 t.join();
		 }
	 }

	 endpoint_type local_endpoint() const {
		 return m_acceptor.local_endpoint();
	 }

private:
	 void fail(bw::error_code ec, std::string what) {
		 if(m_log) {
			 std::cerr << what << ": " << ec.message() << std::endl;
		 }
	 }

	 void maybe_throw(bw::error_code ec, std::string what) {
		 if(ec) {
			 fail(ec, what);
			 throw ec;
		 }
	 }

	 void on_accept(bw::error_code ec) {
		 if(! m_acceptor.is_open()) {
			 return;
		 }
		 if(ec == boost::asio::error::operation_aborted) {
			 return;
		 }
		 maybe_throw(ec, "accept");
		 socket_type sock(std::move(m_socket));
		 m_acceptor.async_accept(
			 m_socket
			 , std::bind(
				 &GWebSocketServerBase::on_accept
				 , this
				 , beast::asio::placeholders::error
			 )
		 );

		 GWebsocketServerSessionBase{false, std::move(sock)};
	 }

	 /**************************************************************************/
	 // Data

	 bool m_log = false;
	 boost::asio::io_service m_ios;
	 socket_type m_socket;
	 boost::asio::ip::tcp::acceptor m_acceptor;
	 std::vector<std::thread> m_thread_vec;
};

/******************************************************************************/
////////////////////////////////////////////////////////////////////////////////
/******************************************************************************/

} /* namespace Courtier */
} /* namespace Gem */

#endif //GENEVA_LIBRARY_COLLECTION_GWEBSOCKETSERVERBASE_HPP

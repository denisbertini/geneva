Target systems
==============

The Geneva library has been developed on OpenSUSE systems (version 11.x) and nowadays
the main development work is done on Ubuntu 9.10. While it is likely that the same code
will compile on any other Linux and possibly Unix platforms (particularly if gcc versions
newer than 4.3 are used), only Debian and Scientific Linux (RHEL clone) systems have been
tested in addition to Ubuntu.
The authors would very much appreciate your feedback, if you manage to compile the
library on other systems than those mentioned here.

Building and Installing
=======================

a) The easy (but yet somewhat untested) way
-------------------------------------------

Geneva comes with a build script that facilitates the somewhat complicated call to
cmake. Assuming you are in $HOME/build and Geneva is in $HOME/Geneva, copy the config
file over:

cp ../Geneva/genevaConfig.gcfg ./myGenevaConfig.gcfg

Adapt the variables in the file appropriately. Then call

sh ../Geneva/prepareBuild.sh ./myGenevaConfig.gcfg

Finally build and install in the usual way:

make		# Use the -j2 switch if you have a dual core CPU
make install

You can clean up the build folder by running "make clean" inside of $HOME/build .

Don't blame us if this procedure does not work (but do let us know!)

b) Direct call to cmake
-----------------------

The build system now uses CMake in version 2.6, which is required due
to the availability of the FindBoost macro.

You will need a copy of Boost (see http://www.boost.org), in version
1.36 or newer. See either the Appendix "Installing Boost in Debian/Ubuntu" or
the Appendix "Compiling Boost" below for more details.

In order to compile this project and the examples:

Create a build directory anywhere in the file system and change into it. Then call

cmake /path/to/geneva-top-dir

followed by a simple "make" and "make install".

In order to choose a custom installation directory (instead of the default
/opt/geneva), call

cmake /path/to/geneva-top-dir -DCMAKE_INSTALL_PREFIX="/where/the/library/goes"

Note that under Linux, you will have to make the installation directory known
to the linker, so henceforth you can link to the library. Under most Linux
systems this can be done by creating a file /etc/ld.so.conf.d/geneva.conf
with the content

/where/the/library/goes/lib

You then need to execute "ldconfig -v". Otherwise you can export the library
location prior to compiling programs based on Geneva:

export LD_LIBRARY_PATH="/where/the/library/goes/lib:$LD_LIBRARY_PATH"

Somewhat older distributions won't provide a new enough Boost version (i.e.,
at least 1.36). You might thus have compiled your own version of Boost, and have
installed it in a non-standard location. In order for CMake to find this directory,
you can either edit the top-level CMakeLists.txt file and hard-code the paths
(uncomment the appropriate entries there), or provide the necessary variables at
the command line when calling cmake. This can be done in the following way
(assuming that Boost is installed in /opt/boost142):

cmake /path/to/geneva-top-dir -DBOOST_ROOT="/opt/boost142"\
                              -DBOOST_INCLUDEDIR="/opt/boost142/include/boost-1_42/"\
                              -DBOOST_LIBRARYDIR="/opt/boost142/lib"

Adding another define -DGENEVA_BUILD_TYPE="Release" or -DGENEVA_BUILD_TYPE="Debug"
switches between Release and Debug (default) builds.

Adding a -DCMAKE_VERBOSE_MAKEFILE="1" will allow you to see the command line that was
used to call the compiler.

This command needs to be called on a single line.

The commands shown here were tested on an Ubuntu 9.10 system.

Compiling the OpenBabel example in <GENEVADIR>/associated/ExternalOpenBabel:
You need a current (>= 2.2.0) installation of OpenBabel, including the development
libraries. On OpenSUSE 11.1, these are the packages openbabel and libopenbabel-devel ,
If you have compiled OpenBabel yourself from source and installed it in a non-standard
location (e.g. /opt/openbabel221 for an installation of OpenBabel 2.2.1, then you
need to manually copy the package config file /opt/openbabel221/lib/pkgconfig/openbabel-2.0.pc
to a directory where the pkg-config executable (and with it the corresponding CMake macro)
can find it. On OpenSUSE 11.1, 64 bit, this can be /usr/lib64/pkgconfig/ . Other Linux
distributions will likely have similar directories configured.

Recommended Software
====================

By default a GenEvA population emits information suitable for the ROOT framework
(see http://root.cern.ch). ROOT is a C++ analysis framework widely used in particle
physics. It is built around the C++ interpreter cint. It is recommended to install
ROOT in your system, as also some of the examples emit information in the ROOT format
(they are essentially writing ROOT programs).


Appendix: Installing Boost in Debian/Ubuntu
===========================================

Both Debian "Squeeze" (testing) and Ubuntu 9.10 "Karmic Koala" have the required
Boost packages to be able to compile and run GenEvA:

	libboost-dev
	libboost-date-time-dev
	libboost-filesystem-dev
	libboost-program-options-dev
	libboost-regex-dev
	libboost-serialization-dev
	libboost-system-dev
	libboost-test-dev
	libboost-thread-dev

You can install them all at once with the command:

sudo apt-get install libboost-dev libboost-date-time-dev libboost-filesystem-dev \
	libboost-program-options-dev libboost-regex-dev libboost-serialization-dev \
	libboost-system-dev libboost-test-dev libboost-thread-dev

Note, however, that older versions of the Debian/Ubuntu Boost-test library packages
(libboost-test-dev and the related package libboost-test1.XX-dev) are missing the
test_exec_monitor static library. The package libboost-test1.42-dev is fine
starting from version 1.42.0-3, whereas the version available in Debian Lenny,
Ubuntu Karmic, and Ubuntu Lucid are affected by this problem.
If you can do without compiling the tests and the examples, you can just comment
out the following lines in the main CMakeList.txt file:
	test_exec_monitor			# In the FIND_PACKAGE() statement
	ADD_SUBDIRECTORY (examples)
	ADD_SUBDIRECTORY (tests)


Appendix: Compiling Boost
=========================

Download Boost from http://www.boost.org and extract the compressed file. This will create a
folder "boost_1_40_0", for instance. Change to that folder and, assuming Boost should be
installed in /opt/boost140 (which should be writable), execute

./bootstrap.sh --with-libraries=date_time,filesystem,program_options,regex,serialization,system,thread,test \
               --prefix=/opt/boost140
./bjam
./bjam install

You can add a "-j 2" to the second command if your system has two cores. This will speed up the
otherwise quite long compilation time.

Once done you can use the Boost include path as explained above, with BOOST_ROOT="/opt/boost140".

If FindBoost.cmake has trouble finding the Boost libraries in the specified location, it might
help to compile the library with the bjam flag "--layout=versioned" or "--layout=tagged". This
should not be necessary for boost versions prior to 1.40.

Appendix: Known bugs and (possibly) fixes on some platforms
===========================================================

* GCC 4.3.1 and Boost 1.36.0 (tested on OpenSUSE 11/64 bit and Debian Lenny)

The Boost.data_time library in version 1.36, in conjunction with g++ 4.3.1
(as found for instance in OpenSUSE 11/64 bit and in Debian Lenny) has a
problem in the file <BOOST-ROOT>/include/boost-1_36/boost/date_time/tz_db_base.hpp .
Line 161 should look like this:
[...]
typedef boost::date_time::dst_adjustment_offsets<time_duration_type> dst_adjustment_offsets;
[...]
In the vanilla sources, the scope boost::date_time:: is missing. This doesn't seem to affect older
compiler versions, though.

The sample applications tend to end with a segfault **after main() has ended**. It should not
have an impact on the program results, but is of course nevertheless annoying. Comments
on the Boost mailing list seem to indicate that this is related to a known problem in the
Boost.Serialization library. At the time of writing, early Betas of Boost 1.37 didn't have
this problem anymore.

* Debian Lenny

The gcc compiler in Debian returns a version number string which is not handled
correctly by the CMake versions older than 2.6.2, as the one available in Debian Lenny
(see http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=501024).
You can either install the cmake version from Debian "Testing" or apply the following
patch to /usr/share/cmake-2.6/Modules/FindBoost.cmake before calling cmake for Geneva

================================================================================
--- FindBoost.cmake.orig        2008-10-02 22:18:42.000000000 +0200
+++ FindBoost.cmake     2008-10-02 22:19:00.000000000 +0200
@@ -374,7 +374,7 @@
             ARGS --version
             OUTPUT_VARIABLE _boost_COMPILER_VERSION
         )
-        STRING(REGEX REPLACE ".* ([0-9])\\.([0-9])\\.[0-9] .*" "\\1\\2"
+        STRING(REGEX REPLACE ".* ([0-9])\\.([0-9])\\.[0-9][^ ]* .*" "\\1\\2"
                _boost_COMPILER_VERSION ${_boost_COMPILER_VERSION})
         SET (_boost_COMPILER "-gcc${_boost_COMPILER_VERSION}")
       ENDIF (NOT CMAKE_COMPILER_IS_GNUCC)
================================================================================

NOTE: This procedure is likely not necessary anymore in current versions of Geneva,
as the code is shipped with a copy of a working FindBoost.cmake .
